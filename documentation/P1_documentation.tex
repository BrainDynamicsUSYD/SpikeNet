\documentclass{article}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{tabulary}
\usepackage{listings}
\usepackage{nameref}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}  %use draft
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[misc]{ifsym}
\usepackage[utf8]{inputenc}

\newcommand{\mylstinline}[1] {\colorbox{Lavender}{\lstinline[basicstyle=\ttfamily\footnotesize\color{Black}]|#1|} }
 
 \renewcommand{\labelitemii}{$\circ$}

  
  
\title{SpikeNet Documentation}
\author{Yifan Gu  \\
	Complex System Group, School of Physics, USYD  \\
	yigu8115@gmail.com \\
	}

\date{\today} 

\begin{document}
 \maketitle

\section{Overview}
SpikeNet is a software developed for simulating spiking neuronal networks, of which the design provides the following four features.

\begin{description}

\item [Configurability] SpikeNet supports any user-defined structure of synaptic connectivity topologies, coupling strengths and conduction delays. It can be easily extended by developers to support any variations of integrate-and-fire neuron and synapse models. For the models that are currently available, see \nameref{sec:model}.

\item [Performance]  Simulation of spiking neuronal network quickly becomes computationally intensive if the number of neurons $N$ in the network exceeds a few thousand. To achieve superior performance, various measures have been taken at both algorithmic and implementation level. Notably, at the algorithmic level, kinetic models are exclusively chosen for their algorithmic efficiency (e.g., \cite{destexhe1998kinetic, vogels2011inhibitory, hennig2015theoretical, treves1993mean}). Furthermore, for such kinetic models, computational cost of the simulation can be dramatically reduced  with the commonly used mathematical abstraction that synapses can be simplified into a few groups, within which their dynamics (or more specifically, the time constants) are identical \cite{destexhe1994efficient}. At the implementation level, C\texttt{++}, a programming language renowned for its high-performance computing, is used.

\item [User-friendly interface] In SpikeNet, although, C\texttt{++}  is used for heavy-duty computation, its user-interface is written in a high-level programming language (Matlab) for user-friendliness. This means SpikeNet does not require non-developer users to be familiar with C\texttt{++}. In practise, the typical work-flow of SpikeNet user is as following.
\begin{enumerate}
\item In Matlab, use SpikeNet functions to generate the input files (plain text) that define the simulation case.
\item Evoke the SpikeNet C\texttt{++} simulator, which reads the input files, runs the simulation and generates the output files.
\item In Matlab, use SpikeNet functions to parse the output files (plain text) into Matlab data for post-processing.
\end{enumerate}
Please see \nameref{sec:matlab user interface} for more detailed descriptions of the work-flow. Developer users will be interested to know that the data format of the aforementioned input and output files follows pre-defined protocols (see \nameref{sec:Output protocols} and \nameref{sec:Input protocols}). This design essentially makes the SpikeNet C\texttt{++} simulator a stand-alone software. Based on these protocols, the C\texttt{++} simulator can easily interface with any other high-level programming languages if Matlab is not prefered.

\item [Scalability] The design of the SpikeNet C\texttt{++} simulator readily supports parallel computing used Message Passing Interface (MPI). The simulator has two central C\texttt{++} classes, representing populations of neurons and synaptic connectivities among these populations, respectively. For example, for a recurrent network consisting of an excitatory neuron population ($E$) and an inhibitory one ($I$), two neuron population objects will be created together with up to four synaptic connectivity objects including $E\leftarrow E$, $I\leftarrow E$, $E\leftarrow I$ and $I\leftarrow I$. These six objects can be created and simulated in parallel and the amount of message passing among them at each simulation time step is minimal.  
\end{description}
 
\section{Tech Stack}
\begin{itemize}
\item C\texttt{++}11 standard is required (GCC 4.2.1 or later; Intel C++ 12.0 or later).
\item Matlab is optional but highly recommended.
\item Portable Batch System (PBS) is optional but highly recommended.
\item Message Passing Interface (MPI) implementation is optional.
\end{itemize}
 
\section{Quickstart}
Following are the steps to set up the SpikeNet C\texttt{++} simulator.
\begin{itemize}
\item Ask for read permission from one of the contributors with admin rights.
\item Make a new directory: \mylstinline{mkdir tmp; cd tmp}
\item Clone SpikeNet: \mylstinline{git clone git@github.com:BrainDynamicsUSYD/SpikeNet.git}
\item Go into the directory: \mylstinline{cd SpikeNet}
\item Build the C\texttt{++} simulator:  \mylstinline{make; make clean; cd ..; ls}
\end{itemize}
Now you should see the ``simulator'' in the current directory, with which you can run simulations by creating input files according to \nameref{sec:Input protocols}.
However, it will be much easier to work with the Matlab user interface.
If you do not have access to Matlab, try to contact the contributors to request interfaces with other high-level programming languages (Python for example).
Following are the steps to use the Matlab user interface.
\begin{itemize}
\item Make a new directory for storing data: \mylstinline{mkdir tmp_data}
\item Start Matlab: \mylstinline{matlab -nodisplay}
\item Set up the environment for Matlab: \mylstinline{cd SpikeNet; addpath(genpath(cd));}
\item Generate the example input files: \mylstinline{cd ../tmp_data; main_demo;}
\item Quit Matlab: \mylstinline{quit}
\item Run the simulator with the input files: \mylstinline{cd tmp_data; ../simulator *ygin;}
\item Start Matlab: \mylstinline{cd ..; matlab -nodisplay}
\item Set up the environment for Matlab: \mylstinline{cd SpikeNet; addpath(genpath(cd));}
\item Parse the output files, run some basic post-processing and visualization: \mylstinline{cd ../tmp_data; PostProcessYG()}
\item Load the simulation result: \mylstinline{d = dir(`*RYG.mat'); R = load(d(1).name)} (You may need to correct the single quotes in Matlab if you are directly copying the code from here.)
\end{itemize}
For those who have access to a high-performance computing cluster with PBS, SpikeNet also provides bash script that fully automates the above Matlab $\rightarrow$  C\texttt{++}  $\rightarrow$ Matlab workflow for PBS job array submission. 
\begin{itemize}
\item Go to the tmp directory
\item Make a copy of the script: \mylstinline{cp SpikeNet/*sh.bak all_in_one.sh}
\item Change it to executable: \mylstinline{chmod +x all_in_one.sh}
\item Edit the following variables in the bash script accordingly: 
\begin{itemize}
\item {\footnotesize MATLAB\_PRE\_PROCESS\_FUNC=`your\_function'}
\item {\footnotesize MATLAB\_POST\_PROCESS\_FUNC=`your\_function'}
\item {\footnotesize MATLAB\_SOURCE\_PATH=`SpikeNet'}
\end{itemize}
\item Make a directory for PBS output: \mylstinline{mkdir PBSout}
\item Submit the job: \mylstinline{qsub -t 1-X -q queue_name all_in_one.sh}
\end{itemize}
For MPI jobs with SpikeNet, please contact Yifan Gu for more technical details.

\section{Matlab user interface}
\label{sec:matlab user interface}
See main\_demo.m.

(More need to be added on the available post-processing Matlab functions. SpikeNet has a variety of statistical analysis and visualization tools for spiking networks.)

\section{Neuron and synapse models}
\label{sec:model}


\numberwithin{equation}{section}

The default neuron model in SpikeNet is leaky integrate-and-fire neuron. 
The membrane potential $V^{\alpha}_{i}$ of the $i$-th neuron ($i=1,\cdots,N_{\alpha}$) from population $\alpha$ evolves according to

\begin{equation}
C_{m}\frac{dV^{\alpha}_{i}}{dt} = -g_{L}(V^{\alpha}_{i}-V_{L}) + I^{\alpha}_{i,syn}(t) + I^{\alpha}_{i,app}(t), \text{ if } V^{\alpha}_{i} < V_{th}.
\end{equation}
When neurons reach the threshold $V_{th}$, a spike is emitted and they are reset to $V_{rt}$ for an absolute refractory period $\tau_{ref}$. 
The spike times $t^{\alpha}_{i}$ are recorded.

The default synapse model in SpikeNet is conductance-based. 
The synaptic currents received by a neuron are given by

\begin{align}
I^{\alpha}_{i,syn}(t) &= \sum_{\beta=1}^{P}I^{\alpha\beta}_{i}(t) \\
 &= \sum_{\beta=1}^{P}[-g_{i}^{\alpha\beta}(V^{\alpha}_{i}-V_{rev}^{\beta})] \\
 &= \sum_{\beta=1}^{P}\{-[\sum_{j=1}^{N_{\beta}}a_{ij}^{\alpha\beta}g_{ij}^{\alpha\beta}s_{ij}^{\alpha\beta}(t)](V^{\alpha}_{i}-V_{rev}^{\beta})\}\label{eq:I_syn}
\end{align}


\noindent
where $V_{rev}^{\beta}$ is the reversal potential of the corresponding current $I^{\alpha\beta}_{i}$ induced by pre-synaptic population $\beta$. 
$a_{ij}^{\alpha\beta}$ is a binary variable which determines the existence of synapse from the $j$-th neuron in population $\beta$ to the $i$-th neuron in  population $\alpha$, while $g_{ij}^{\alpha\beta}$ reflects the (maximal) strength of the synaptic conductance. 
The gating variable $s_{ij}^{\alpha\beta}(t)$ models the instananeous value of synaptic conductance in terms of the fraction of open channels, described by

\begin{equation}
\frac{ds_{ij}^{\alpha\beta}}{dt} = -\frac{s_{ij}^{\alpha\beta}}{\tau_{d}^{\beta}}+\sum_{t^{\beta}_{j}}h^{\beta}(t-t^{\beta}_{j}-d^{\alpha\beta}_{ij})(1-s_{ij}^{\alpha\beta})
\label{eq:gating}
\end{equation}

\noindent
where $h$ models the concentration time-course of the channel-opening neurotransmitters, arrived with a conduction delay $d^{\alpha\beta}_{ij}$ after the pre-synaptic spike time $t^{\beta}_{j}$. 
The $(1-s_{ij}^{\alpha\beta})$ term introduces saturation effect. 
Following the simplification in \cite{destexhe1994efficient}, a rectangular pulse with unitary area is used for $h$

\begin{equation}
h(t) = 
\begin{cases}
1/\tau_{r},& \text{ if } 0\leq t \leq \tau_{r}\\
0,& \text{ otherwise}
\end{cases}
\end{equation}


% The default parameters are summarized in Table \ref{table:model constants}. 
All numerical values are in consistant units unless mentioned otherwise (ms for time, mV for voltage, nA for current, nF for capacitance and ${\mu}$S for conductance). 
Default numerical integration is performed using Euler method and the suggested time-step is 0.1 ms\cite{litwin2012slow}.



%\begin{table}
%\begin{center}
%  \begin{tabulary}{3.0\textwidth}{RRR}
%	$\alpha$  & E & I \\
%	\hline
%	$\tau_{r}^{\alpha}$ (ms) & 1 & 1\\
%	$\tau_{d}^{\alpha}$ (ms) & 5 & 3 \\
%	$V_{rev}^{\alpha}$ (mV) & 0 & -80 \\
%	
%	$\tau_{ref}$ (ms) & \multicolumn{2}{c}{2} \\
%	$C_{m}$ (nF) & \multicolumn{2}{c}{0.25} \\
%	$g_{L}$ ($\mu$S) & \multicolumn{2}{c}{0.0167} \\
%	$V_{L}$ (mV) & \multicolumn{2}{c}{-70} \\
%	$V_{rt}$ (mV) & \multicolumn{2}{c}{-60} \\
%	$\theta$ (mV) & \multicolumn{2}{c}{-50} \\
%  \end{tabulary}  
%  \caption{Model constants}
%  \label{table:model constants}
%\end{center}
%\end{table}




\section{Input protocols}
\label{sec:Input protocols}

The input files are plain text files.
The default input filename is ``filename.ygin''.
It is advised that synapse definitions always be given in a separate file.
The default synapse definition filename is ``filename.ygin\_syn''.
Non-default synapse definition file path and name can be specified by ``SYNF001'' protocol.
Following is the complete list of the input data protocols.
Note that the protocols use three special characters, including ``\textgreater'' for starting a new protocol, ``\#'' for commenting and "," for delimiting.

\lstset{
  basicstyle=\fontsize{9}{11}\selectfont\ttfamily
}

\begin{lstlisting}[mathescape]

> INIT001 # number of neurons in each population
	N1, N2, ...,

> INIT002 # time step length and total number of steps
	dt (ms), step_tot,

> INIT003 # random initial distributions for V (deprecated)
	p_fire_pop1 (range ($-\infty$,1]), ..., p_fire_popN, 

> INIT004 # external Gaussian currents
	pop_ind, 
	mean_1 (nA), mean_2, ...,  mean_N, (for each neuron)
	std_1 (nA), std_2, ...,  std_N, 

> INIT005 # external Poissonian spikes
	pop_ind, type_ext, K_ext ($\mu$S), Num_ext, ia, ib,
	rate_1 (Hz), rate_2, ..., rate_step_tot

> INIT006 # chemical connection definition
	type, pop_ind_pre, pop_ind_post,
	I (row vector),
	J (row vector),
	K (row vector),
	D (row vector),

> INIT007 # set perturbation (remove one spike)
	pop_ind, step_perturb,

> INIT008 # add short-term depression
	pop_ind_pre, pop_ind_post, STD_on_step,

> INIT009 # add inhibitory STDP
	pop_ind_pre, pop_ind_post, STDP_on_step,
	
> INIT010 # add spike-frequency adaptation 
	pop_ind,

> INIT011 # random initial conditions for V and firing probabilities
	r_V0_pop1 (range (0,1]), ...,r_V0_popN, 
	p_fire_pop1 (range (0,1]), ..., p_fire_popN, 
	
> SYNF001 # non-default synapse definition file name
	path/to/file_name (no comma!)

> KILL001 # runaway killer setting
	pop_ind, min_ms, runaway_Hz, Hz_ms,

> PARA001 # non-default neuron population parameter
	pop_ind, number_of_parameters,
	parameter_name1, value1,
	parameter_name2, value2,
	...
 
> PARA002 # non-default synapse parameter
	number_of_parameters,
	parameter_name1, value1,
	parameter_name2, value2,
	...

> SAMP001 # neuron data sampling 
	pop_ind,
	data_type (logical vector),
	ind1, ind2, ..., indX, (sample neuron indices)
	1, 1, 0, 0, ..., (1-by-step_tot logical values)
	# Note that data_type specifies sample data types
	# and it must correspond to 
	# [V,I_leak,I_AMPA,I_GABA,I_NMDA,I_GJ,I_ext]

> SAMP002 # synapse data sampling 
	pop_ind_pre, pop_ind_post, syn_type,
	ind1, ind2, ..., indX, (post-synaptic sample neuron indices)
	1, 1, 0, 0, ..., (1-by-step_tot logical values)
	
> SAMP003 # neuron population statistical data record
	pop_ind,
	
> SAMP004 # synaptic currents  statistical data record
	pop_ind_pre, pop_ind_post, syn_type,

\end{lstlisting}

\section{Output protocols}
\label{sec:Output protocols}
The output files are plain text files.
The default output filename is ``filename-X.ygout'', where X is a time-stamp that uniquely marks the output file so that multiple simulations can be run for the same input files.
For data completeness, the corresponding input file will be attached to the output file.
Following is the complete list of the output data protocols.
\begin{lstlisting}

> KILL002 # step at which runaway activity is killed
	step_killed,

> POPD001 # spike history of neuron population
	pop_ind,
	spike_neuron_ind (row vector),
	num_spikes_t (1-by-step_tot row vector),
	num_ref_t (1-by-step_tot row vector),

> POPD002 # neuron parameters in the population
	pop_ind, number_of_parameters,
	parameter_name1, value1,
	parameter_name2, value2,
	...

> POPD003 # neuron population statistical data
	pop_ind,
	V_mean_t1, V_mean_t2, ... (1-by-step_tot)
	V_std_t1, V_std_t2, ... (1-by-step_tot)
	I_input_mean_t1, I_input_mean_t2, ... (1-by-step_tot)
	I_input_std_t1, I_input_std_t2, ... (1-by-step_tot)
	
> POPD004 # sampled neuron data (deprecated)
	pop_ind, number_of_sample_neurons,
	data_name1, ..., data_nameX,
	data_1 (sampled_neurons-by-sampled_steps matrix),
	data_2 (sampled_neurons-by-sampled_steps matrix),
	...
	data_X (sampled_neurons-by-sampled_steps matrix),


> POPD005 # E-I ratio for each neuron
	pop_ind,
	EI_ratio_1, EI_ratio_2, ... (1-by-N),
	
> SAMF001 # sampled data file name
	path/to/file_name (no comma!)

> POPD006 # sampled neuron data
	pop_ind, number_of_neurons times number_of_steps
	data_name1, ..., data_nameX,
	step_1 (sampled_neurons-by-data_types matrix),
	step_2 (sampled_neurons-by-data_types matrix),
	...
	step_X (sampled_neurons-by-data_types matrix),
	
> SYND001 # synaptic connection parameters
	number_of_parameters,
	parameter_name1, value1,
	parameter_name2, value2,
	...

> SYND002 # sampled synapse  data
	pop_ind_pre, pop_ind_post, syn_type, number_of_sample_neurons,
	data (sampled_neurons-by-sampled_steps matrix),

> SYND003 # synapse statistical data
	pop_ind_pre, pop_ind_post, syn_type,
	I_mean_t1, I_mean_t2, ... (1-by-step_tot)
	I_std_t1, I_std_t2, ... (1-by-step_tot)
	
	

\end{lstlisting}

\bibliography{P1_documentation}{}
\bibliographystyle{plain}



\end{document}

